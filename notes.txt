Notes

https://editorconfig.org/
used to create .editorconfig file to set vs code editor

Package Managers
	use npm

node security platform - command line check for security vulnerablities - 'nsp check' in console
	when to run security check
		manually - easy to forget
		npm install - may be have an issue later
		prod build - expensive to change
		pull request - expensive to change
		npm start - slows start slightly

Local Web Servers

express for local development
	comprehensive
	highly configurable
	production grade
	can run it everywhere

Webpack Dev Server
	built into Webpack
	serves from memory
	includes hot reloading

Browsersync
	Dedicated IP for sharing work on LAN
	All interactions remain in sync!
	great for cross-device testing
	Integrates with Webpack, gulp, express and more



Sharing Work-in-progress

	localtunnel - Easily share work on your local machine
		setup:
		1. npm install localtunnel -g
		2. Start your app
		3. in console -- lt --port 3000
			can also specifiy specific subdomain
				lt --port 3000 --subdomain <whatever>

	ngrok - secure tunnel to your local machine
		setup
		1. Sign up
		2. intall ngrok
		3. install authtoken
		4. start your app
		5. ./ngrok http 80

	now - easy way to deploy to the cloud - supports node.js projects
		setup
		1. npm install -g now
		2. create start script
		3. in console -- now

	surge - Quickly host static files to public URL
		Setup:
		1. npm install -g surge
		2. in console -- surge


Automation Options

	Grunt - the orginal
		configuaration over code
		writes intermediary files between steps
		large plugin ecosystem

	Gulp -
		in-memory streams called pipes
		faster than grunt
		code over configuaration
		large plugin ecosystem

	npm Scripts - uses packages directly
		declared in package.json
		leverage your OS' command line
		directly use npm packages
		call node scripts
		convention-based pre/post hooks
		leverage world's largest package manager

	 with npm scripts
	 	add a script in the package.json

		 example:
		 	"scripts": {
				"prestart" : "node buildScripts/startMessage.js",
				"start" : "node buildScripts/srcServer.js"
			}

		Concurrent Tasks - you can chain your npm scripts together using npm-run-all --parallel

			example:
				"scripts": {
					"prestart" : "node buildScripts/startMessage.js",
					"start" : "npm-run-all --parallel security-check open:src",
					"open:src" : "node buildScripts/srcServer.js",
					"security-check" : "nsp check",
					"localtunnel" : "lt --port 3000",
					"share" : "npm-run-all --parallel open:src localtunnel"
				}

	Transpiling
		Babel
		TypeScript
		Elm

		Babel
			Modern, standard-based JS, today
			transpiles latest version of JS down to ES5
			write standardized JS
			leverage full JS ecosystem
			use experimental features
			no type defs, annotations required
			ES6 imports are staticlly analyzable
			Test, Lint, Babel, Great libs, IDE = safety

		TypeScript
			superset of javascript
			adds additional functionality to JS
			enhanced autocomplete
			enhanced readabilty
			safer refactoring
			additional non-standard features


		BABEL
			.babelrc vs package.json

				.babelrc - not npm specific and easier to read since isolated
				package.json - one less file in your project
					example:
						{
							"name" : "my-package",
							"version" : "1.0.0",
							"babel" : {
								// bable config here
							}
						}

			Build Script JS Style

				ES5
					- no waiting for transpile = faster
					- no transpiler dependency

				Transpiled
					- Enjoy the latest features
					- consistent coding style
					- use the same linting rules everywhere
					- can eventually remove transpiler

	Bundling
		commonJS does not work in the browser

		5 module formats
			IFFE
			Ayschronous Module Definition (AMD)
			CommonJS (CJS)
			Universal Module Definition (UMD)
			ES6 Modules

			should be using CommonJS or ES6 Modules
				- ES6 are standardized
				- Statically analyzable
					improve autocomplete
					intelligent refactoring
					Fails faster
					tree shaking (removes unused code)
				- Easier to read
					- named imports
					- default exports

		Require.js - first popular one, not used much anymore

		Rollup - fiirst to offer tree shaking
			- faster loading production code
			- quite new
			- great for library
			- no hot reloading or code splitting

		JSPM - Uses systemJS, a univeral module loader
			- can load modules at runtime
			- has own package manager
			- uses Rollup

		Browserify - OG bundler
			bundle npm packages for the web
			large plugin ecosystem

		webpack - bundle more than JS
			- import CSS, images, etc like JS
			- built in hot-reloading web server
			- bundle splitting




